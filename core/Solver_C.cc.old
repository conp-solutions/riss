/**************************************************************************************************

Solver_C.C

C-wrapper for Solver.C

  This file is part of NuSMV version 2. 
  Copyright (C) 2007 by FBK-irst. 
  Author: Roberto Cavada <cavada@fbk.eu>

  NuSMV version 2 is free software; you can redistribute it and/or 
  modify it under the terms of the GNU Lesser General Public 
  License as published by the Free Software Foundation; either 
  version 2 of the License, or (at your option) any later version.

  NuSMV version 2 is distributed in the hope that it will be useful, 
  but WITHOUT ANY WARRANTY; without even the implied warranty of 
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public 
  License along with this library; if not, write to the Free Software 
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA.

  For more information on NuSMV see <http://nusmv.fbk.eu>
  or email to <nusmv-users@fbk.eu>.
  Please report bugs to <nusmv-users@fbk.eu>.

  To contact the NuSMV development board, email to <nusmv@fbk.eu>. ]

**************************************************************************************************/


#include "lib-src/librissc.h"  // include the actual library interface of riss


extern "C" {
#include "Solver_C.h"
}

extern "C" MiniSat_ptr MiniSat_Create()
{
  // return the usual Riss Binary
  return (MiniSat_ptr) riss_init();
}

extern "C" void MiniSat_Delete(MiniSat_ptr ms)
{
  // destroy the riss solver object
  riss_destroy(ms);
}

extern "C" int MiniSat_Nof_Variables(MiniSat_ptr ms)
{
  // return the number of variables of the solver
  return riss_variables( ms );
}

extern "C" int MiniSat_Nof_Clauses(MiniSat_ptr ms)
{
  return riss_clauses( ms );
}

/* variables are in the range 1...N */
extern "C" int MiniSat_New_Variable(MiniSat_ptr ms)
{
  /* Actually, minisat used variable range 0 .. N-1,
     so in all function below there is a convertion between
     input variable (1..N) and internal variables (0..N-1)
  */	
  return riss_new_variable (ms) ; + 1;
}


/*
 * Here clauses are in dimacs form, variable indexing is 1...N
 */
extern "C" int MiniSat_Add_Clause(MiniSat_ptr ms,
                                  int *clause_lits, int num_lits)
{
  int i, ret = 0;
  
  for(i = 0; i < num_lits; i++) {
    const int lit = clause_lits[i];
    assert(abs(lit) > 0);
    assert(abs(lit) <= MiniSat_Nof_Variables(ms));
    ret = riss_add ( ms, lit ) || ret;  // collect all return codes disjunctively
  }
  ret = riss_add ( ms, 0 ) || ret; // add a terminating 0
  return ret;
}

extern "C" int MiniSat_Solve(MiniSat_ptr ms)
{
  // return 1, if the current formula is satisfiable
  assert( riss_assumptions(ms) == 0 );
  return (10 == riss_sat ( ms )) ? 1 : 0;
}


/*
 * Here the assumption is in "dimacs form", variable indexing is 1...N
 */
extern "C" int MiniSat_Solve_Assume(MiniSat_ptr ms,
                                    int nof_assumed_lits,
                                    int *assumed_lits)
{
  int i;
  vec<Lit> cl;
  assert(ms != 0); 

  if( 0 == riss_simplify( ms ) ) return 0; // unit propagation failed

  assert(nof_assumed_lits >= 0);
  assert( riss_assumptions(ms) == 0 && "there should not be old assumption variables left" );
  
  for(i = 0; i < nof_assumed_lits; i++) {
    const int lit = assumed_lits[i];
    assert(abs(lit) > 0);
    assert(abs(lit) <= MiniSat_Nof_Variables((Solver*)ms->solver));
    riss_assume (ms, lit);
  }

  return (10 == riss_sat ( ms )) ? 1 : 0; // return 1, if the SAT call was successful
}

extern "C" int MiniSat_simplifyDB(MiniSat_ptr ms)
{
  return 0 == solver.simplify() ? 0 : 1; // return 0, if simplificatoin failes
}

/*
 * Here variables are numbered 1...N
 */
extern "C" int MiniSat_Get_Value(MiniSat_ptr ms, int var_num)
{
  assert(var_num > 0);
  if(var_num > MiniSat_Nof_Variables(ms) )
    return -1;
  /* minisat assigns all variables. just check */
  assert( riss_deref (ms, var_num) != 0 ); 
  
  return riss_deref (ms, var_num) == 1 ? 1 : 0;
}


extern "C" int MiniSat_Get_Nof_Conflict_Lits(MiniSat_ptr ms)
{
  assert( 0 != ms ); 
  return riss_conflict_size (ms);
}

extern "C" void MiniSat_Get_Conflict_Lits(MiniSat_ptr ms, int* conflict_lits)
{
  assert( 0 != ms ); 

  const int conflictSize = riss_conflict_size( ms );
  for (int i = 0; i < conflictSize; i++) {
    conflict_lits[i] = riss_conflict_lit (ms, i);
  }
}

/** not implemented, Riss uses phase_saving heuristic as default */
extern "C" void MiniSat_Set_Polarity_Mode(MiniSat_ptr ms, int mode)
{
}

/** not implemented, Riss uses phase_saving heuristic as default */
extern "C" int MiniSat_Get_Polarity_Mode(MiniSat_ptr ms)
{
  return polarity_false;
}

extern "C" void MiniSat_Set_Random_Seed(MiniSat_ptr ms, double seed)
{
  assert( 0 != ms ); 
  assert( seed >= 0 && seed <= 1 );
  riss_set_randomseed( ms, seed );
}

