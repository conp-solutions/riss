/********************************************************************************[EnumerateMaster.h]
Copyright (c) 2015, All rights reserved, Norbert Manthey

 **************************************************************************************************/

#ifndef ENUMERATEMASTER_H
#define ENUMERATEMASTER_H


#include "riss/mtl/Vec.h"
#include "riss/core/SolverTypes.h"
#include "riss/utils/LockCollection.h"

#include "riss/utils/VarFileParser.h"

#include <cstdio>
#include <iostream>
#include <sstream>

namespace Riss {

/** class that controls enumerating models (with or without projection)
 *  can be used for parallel enumeration
 */
class EnumerateMaster 
{
  SleepLock ownLock;	   // lock for shared access
  bool enumerateParallel;            // use shared access
  
  
  string projectionFileName; // name of the file with the projection variables
  
  int nVars;                // number of variables in formula
  bool useProjection;       // whether projection is active
  string outputFileName;    // name of the file to write the result to
  vec<char> isInProjection; // check for each variable, whether the variable is in the projection
  vector<int> projectionVariables; // all variables in the projection
  int64_t models;
  int64_t maximalModels;        // number of models that should be found
  
  std::stringstream* fileMemory;  // stream to buffer projection into

  /** set up all the data structures necessary for model enumeration */
  void initEnumerateModels();
  
  /** write literals of the given set to the fileMemory stream*/
  void writeModelToStream( vec<Lit>& literalSet, bool doNotInvers = true );  // write the current "disallow-clause" as model into the stream

  /** lock, if object has been set shared before */
  void lock() { if ( enumerateParallel ) ownLock.lock(); };
  
  /** unlock, if object has been set shared before */
  void unlock() { if(enumerateParallel) ownLock.unlock(); };
  
public:
  
  enum MinimizeType {
    NONE = 0,
    ONLYFROMFULL = 1,
    ALSOFROMBLOCKED = 2
  };
  
  EnumerateMaster(int _nVars, string _projectionFileName = "");
  
  /** set the object shared (for parallel enumeration)*/
  void setShared() { assert( models == 0 && "cannot set shared after first models have been found already" ); enumerateParallel = true; }
  
  bool isShared() const { return enumerateParallel; }

  /** return number of found models (so far), not synchronized */
  int foundModels() const { return models; }
  
  /** set number of models to be found ( 0 ^= INT64_MAX )*/
  void setMaxModels( const int64_t m ) { lock(); maximalModels = m == 0 ? INT64_MAX : m ; unlock(); }
  
  /** tell master the client found UNSAT during adding model blocking clauses*/
  void notifyReachedAllModels() ;
  
  /** write fileMemory stream to the output file */
  void writeStreamToFile(string filename = "", bool toerr = false);
  
  /** return whether the specified variable is used in the projection, not synchronized read access*/
  bool varInProjection(const Var& v) const;
  
  /** indicate whether enumeration is based on projection */
  bool usesProjection() const { return useProjection ; }
  
  /** add another model to the master 
   @param model full (wrt projection, if used) model, represented by the trail of the solver 
   @param blockingClause clause that blocks the given model, generated by the client
   @param fullModel pointer to full model, in case the full model should be printed even if projection is used
   @return true, if this model has not been seen before, false if the model is present already (useful for parallel enumeration)
   Note: assumes that a solver blocks each model itself , so that no book-keeping is performed
  */
  bool addModel( Riss::vec< Riss::Lit >& model, Riss::vec< Riss::Lit >* blockingClause  = nullptr, Riss::vec< Riss::Lit >* fullModel = nullptr);
  
  /** tell whether enough models have been found */
  bool foundEnoughModels();
  
  int projectionSize() const;
  
  /** return projection variables, not synchronized read access */
  Var projectionVariable( int index ) const;
  
  /** return the minimization of the blocking clause, that is allowed */
  MinimizeType minimizeBlocked();
};

EnumerateMaster::EnumerateMaster(int _nVars, string _projectionFileName) 
 : 
   enumerateParallel(false)
 , models(0)
 , maximalModels(1)
{
  nVars = _nVars;
  projectionFileName = _projectionFileName;
  if( projectionFileName != "" ) useProjection = true;
  initEnumerateModels();
}

void EnumerateMaster::notifyReachedAllModels()
{
  lock();
  maximalModels = models;
  unlock();  
}

bool EnumerateMaster::addModel(vec< Lit >& model, vec< Lit >* blockingClause, vec< Lit >* fullModel)
{
  lock() ; 
  
  // if we do not have a string stream yet, get one
  
  if(!enumerateParallel) {
    if( fileMemory == 0 ) fileMemory = new stringstream; 
    writeModelToStream( model, false );
    unlock();
    return true;
  } else {
    assert( false && "not yet implemented" );
    unlock();
    exit(13);
  }
}

bool EnumerateMaster::foundEnoughModels() {
  bool result = false;
  lock();
  result = (models >= maximalModels );
  unlock();
  return result;
}


bool EnumerateMaster::varInProjection(const Var& v) const
{
  if( !usesProjection() ) return false; // does not use projection
  if (v > nVars ) return false;         // variable is larger than variables when initializing the object
  return isInProjection[ v ] == 1;      // return indicator for given variable
}

void EnumerateMaster::initEnumerateModels()
{
    if( true ) { // do model counting
      if( isInProjection.size() == 0 && projectionFileName != "") {
	// read in projection variables
        projectionVariables.clear();
        VarFileParser parse ( (string)projectionFileName );  // open file for parsing
        int max = parse.extract(projectionVariables);
	max = max >= nVars ? max : nVars;
	isInProjection.clear();
	isInProjection.growTo( max+1, 0 );
	for( int i = 0 ; i < projectionVariables.size(); ++i ) {
	  assert( projectionVariables[i] > 0 && "should not parse literals, but only variables" );
	  projectionVariables [i] --;                    // minisat representation!
	  isInProjection[ projectionVariables [i] ] = 1; // set to 1
	}
	useProjection = true;
      } else {
	isInProjection.clear();
	isInProjection.growTo( nVars+1, 0 );
	useProjection = false;
      }
    }
}

void EnumerateMaster::writeModelToStream( Riss::vec< Riss::Lit >& literalSet, bool doNotInvers )
{
  if( fileMemory == 0 ) return;
  for( int i = 0 ; i < literalSet.size(); ++ i ) {
    const Lit l = ~literalSet[i];
    if( doNotInvers ) (*fileMemory ) << (sign(l) ? "" : "-") <<  var(l)+1 << " ";
    else (*fileMemory ) << (sign(l) ? "-" : "") <<  var(l)+1 << " ";
  }
  (*fileMemory ) << "0" << endl;
}

void EnumerateMaster::writeStreamToFile(string filename, bool toerr)
{
  if(fileMemory == nullptr || ( outputFileName == "" && filename == "" && !toerr) ) return;
  lock();
  if( outputFileName != "" || filename != "" ) {
    std::ofstream file( filename == "" ? outputFileName.c_str() : filename.c_str() );
    file << fileMemory->str();
    file.close();
  }
  if( toerr ) std::cerr << fileMemory->str();
  unlock();
}

int EnumerateMaster::projectionSize() const
{
  return projectionVariables.size();
}

Var EnumerateMaster::projectionVariable(int index) const
{
  assert( index >= 0 && projectionVariables.size() > index && "stay in bounds" );
  return projectionVariables[ index ];
}

EnumerateMaster::MinimizeType EnumerateMaster::minimizeBlocked()
{
  return ALSOFROMBLOCKED;
}


}

#endif
